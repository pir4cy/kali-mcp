# utils/output_analyzer.py
import re
import json
import logging
from typing import Dict, List, Any

logger = logging.getLogger('kali-mcp.output_analyzer')

# Tool-specific output parsers
def parse_nmap(output: str) -> Dict[str, Any]:
    """Parse nmap output into structured data"""
    result = {
        "hosts": [],
        "ports": [],
        "services": [],
        "os_info": None,
        "script_results": {}
    }
    
    # Extract hosts
    host_matches = re.findall(r'Nmap scan report for ([^\n]+)', output)
    result["hosts"] = host_matches
    
    # Extract ports and services
    port_matches = re.findall(r'(\d+)\/(\w+)\s+(\w+)\s+([^\n]+)', output)
    for port in port_matches:
        port_num, protocol, state, service = port
        result["ports"].append({
            "port": port_num,
            "protocol": protocol,
            "state": state,
            "service": service.strip()
        })
        if state.lower() == 'open':
            result["services"].append(f"{service.strip()} on port {port_num}/{protocol}")
    
    # Extract OS detection
    os_match = re.search(r'OS details: ([^\n]+)', output)
    if os_match:
        result["os_info"] = os_match.group(1).strip()
    
    return result

def parse_nikto(output: str) -> Dict[str, Any]:
    """Parse nikto output into structured data"""
    result = {
        "target": None,
        "findings": [],
        "vulnerabilities": []
    }
    
    # Extract target
    target_match = re.search(r'- Target: ([^\n]+)', output)
    if target_match:
        result["target"] = target_match.group(1).strip()
    
    # Extract findings
    findings = re.findall(r'\+ ([^\n]+)', output)
    result["findings"] = findings
    
    # Extract potential vulnerabilities (simplified)
    for finding in findings:
        if any(x in finding.lower() for x in ["vulnerability", "vulnerable", "exploit", "disclosure", "exposed"]):
            result["vulnerabilities"].append(finding)
    
    return result

# Main analysis function
def analyze_output(tool: str, output: str, detail_level: str = "concise") -> str:
    """
    Analyze tool output and provide insights
    
    Args:
        tool: Tool name that generated the output
        output: Raw output to analyze
        detail_level: Level of detail for the analysis (concise or detailed)
    
    Returns:
        Analysis of the output
    """
    logger.info(f"Analyzing output from {tool} with detail level: {detail_level}")
    
    # Handle empty output
    if not output or output.strip() == "":
        return "No output was generated by the tool."
    
    # Select parser based on tool
    parser_func = None
    if tool == "nmap":
        parser_func = parse_nmap
    elif tool == "nikto":
        parser_func = parse_nikto
    
    # Parse the output if we have a parser
    parsed_data = None
    if parser_func:
        try:
            parsed_data = parser_func(output)
        except Exception as e:
            logger.error(f"Error parsing {tool} output: {str(e)}")
    
    # Generate analysis
    analysis = f"## Analysis of {tool} output\n\n"
    
    if parsed_data:
        # Tool-specific analysis
        if tool == "nmap":
            analysis += generate_nmap_analysis(parsed_data, detail_level)
        elif tool == "nikto":
            analysis += generate_nikto_analysis(parsed_data, detail_level)
    else:
        # Generic analysis for tools without specific parsers
        analysis += generate_generic_analysis(tool, output, detail_level)
    
    # Always include the raw output if detail level is detailed
    if detail_level == "detailed":
        analysis += "\n\n## Raw Output\n\n```\n"
        # Limit raw output to avoid excessive responses
        if len(output) > 5000:
            analysis += output[:5000] + "\n\n... [output truncated] ...\n"
        else:
            analysis += output
        analysis += "\n```"
    
    return analysis

def generate_nmap_analysis(data: Dict[str, Any], detail_level: str) -> str:
    """Generate analysis for nmap results"""
    analysis = ""
    
    # Add host information
    if data["hosts"]:
        analysis += f"### Target Hosts\n\n"
        analysis += ", ".join(data["hosts"])
        analysis += "\n\n"
    
    # Add port information
    if data["ports"]:
        open_ports = [p for p in data["ports"] if p["state"].lower() == "open"]
        filtered_ports = [p for p in data["ports"] if p["state"].lower() == "filtered"]
        
        analysis += f"### Open Ports: {len(open_ports)}\n\n"
        if open_ports:
            if detail_level == "concise" and len(open_ports) > 5:
                # Summarize if there are many ports
                common_services = ", ".join(set([p["service"].split()[0] for p in open_ports[:5]]))
                analysis += f"Found {len(open_ports)} open ports including services like {common_services}.\n\n"
            else:
                # List all ports in detail mode or if there are few ports
                for port in open_ports:
                    analysis += f"- {port['port']}/{port['protocol']}: {port['service']}\n"
                analysis += "\n"
        else:
            analysis += "No open ports were found.\n\n"
        
        # Only include filtered ports in detailed view
        if detail_level == "detailed" and filtered_ports:
            analysis += f"### Filtered Ports: {len(filtered_ports)}\n\n"
            for port in filtered_ports[:10]:  # Limit to avoid excessive output
                analysis += f"- {port['port']}/{port['protocol']}\n"
            if len(filtered_ports) > 10:
                analysis += "- ... and others\n"
            analysis += "\n"
    
    # Add OS information if available
    if data["os_info"]:
        analysis += f"### Operating System Detection\n\n"
        analysis += f"{data['os_info']}\n\n"
    
    # Add security implications
    analysis += "### Security Implications\n\n"
    
    if not data["ports"] or not any(p["state"].lower() == "open" for p in data["ports"]):
        analysis += "No open ports detected, the target may be offline, protected by a firewall, or not responding to scans.\n"
    else:
        open_services = [p["service"].lower() for p in data["ports"] if p["state"].lower() == "open"]
        
        # Check for common high-risk services
        high_risk = []
        if any("ssh" in s for s in open_services):
            high_risk.append("SSH service is exposed and may be vulnerable to brute force attacks")
        if any("telnet" in s for s in open_services):
            high_risk.append("Telnet service is exposed, which transmits data in cleartext")
        if any(s.startswith("rpc") for s in open_services):
            high_risk.append("RPC services may have vulnerabilities")
        if any("smb" in s or "netbios" in s for s in open_services):
            high_risk.append("SMB/NetBIOS services may expose the system to various attacks")
        
        if high_risk:
            analysis += "**Potential Security Concerns:**\n\n"
            for risk in high_risk:
                analysis += f"- {risk}\n"
        else:
            analysis += "No obvious high-risk services detected in initial scan.\n"
    
    # Add recommendations
    analysis += "\n### Recommended Next Steps\n\n"
    
    if data["ports"] and any(p["state"].lower() == "open" for p in data["ports"]):
        analysis += "1. Run vulnerability scans against the open services\n"
        analysis += "2. Verify that all exposed services are necessary\n"
        analysis += "3. Check for outdated software versions\n"
        if detail_level == "detailed":
            analysis += "4. Consider targeted testing with tools specific to the discovered services\n"
            analysis += "5. Review firewall rules and network segmentation\n"
    else:
        analysis += "1. Try different scan types (e.g., -sU for UDP)\n"
        analysis += "2. Check if the target implements firewall rules\n"
        analysis += "3. Verify the target is online and reachable\n"
    
    return analysis

def generate_nikto_analysis(data: Dict[str, Any], detail_level: str) -> str:
    """Generate analysis for nikto results"""
    analysis = ""
    
    # Add target information
    if data["target"]:
        analysis += f"### Target\n\n{data['target']}\n\n"
    
    # Add vulnerability summary
    if data["vulnerabilities"]:
        analysis += f"### Vulnerabilities: {len(data['vulnerabilities'])}\n\n"
        
        if detail_level == "concise" and len(data["vulnerabilities"]) > 5:
            # Summarize in concise mode
            analysis += f"Found {len(data['vulnerabilities'])} potential vulnerabilities including:\n\n"
            for vuln in data["vulnerabilities"][:3]:
                analysis += f"- {vuln}\n"
            analysis += f"- ... and {len(data['vulnerabilities']) - 3} more\n\n"
        else:
            # List all in detailed mode
            for vuln in data["vulnerabilities"]:
                analysis += f"- {vuln}\n"
            analysis += "\n"
    else:
        analysis += "### No clear vulnerabilities detected\n\n"
    
    # Add general findings
    if data["findings"] and len(data["findings"]) > len(data["vulnerabilities"]):
        other_findings = [f for f in data["findings"] if f not in data["vulnerabilities"]]
        
        if other_findings:
            analysis += f"### Other Findings: {len(other_findings)}\n\n"
            if detail_level == "concise" and len(other_findings) > 5:
                for finding in other_findings[:3]:
                    analysis += f"- {finding}\n"
                analysis += f"- ... and {len(other_findings) - 3} more\n\n"
            else:
                for finding in other_findings:
                    analysis += f"- {finding}\n"
                analysis += "\n"
    
    # Add security implications
    analysis += "### Security Implications\n\n"
    
    if data["vulnerabilities"]:
        analysis += "The scan identified potential security issues that could be exploited:\n\n"
        
        # Categorize vulnerabilities
        info_disclosure = any("disclosure" in v.lower() or "information" in v.lower() for v in data["vulnerabilities"])
        outdated_software = any("outdated" in v.lower() or "version" in v.lower() for v in data["vulnerabilities"])
        misconfigurations = any("misconfiguration" in v.lower() or "default" in v.lower() for v in data["vulnerabilities"])
        
        if info_disclosure:
            analysis += "- **Information Disclosure**: The server may be revealing sensitive information\n"
        if outdated_software:
            analysis += "- **Outdated Software**: The server may be running outdated software with known vulnerabilities\n"
        if misconfigurations:
            analysis += "- **Misconfigurations**: The server may have security misconfigurations\n"
    else:
        analysis += "No clear vulnerabilities were detected in the initial scan. However, this doesn't guarantee the absence of security issues.\n"
    
    # Add recommendations
    analysis += "\n### Recommended Next Steps\n\n"
    
    if data["vulnerabilities"]:
        analysis += "1. Address the identified vulnerabilities, prioritizing the most critical ones\n"
        analysis += "2. Update server software and configurations\n"
        analysis += "3. Consider more in-depth testing with specific tools\n"
        if detail_level == "detailed":
            analysis += "4. Review the web server's security headers and configurations\n"
            analysis += "5. Consider implementing a web application firewall\n"
            analysis += "6. Conduct regular security assessments\n"
    else:
        analysis += "1. Perform additional scans with different tools\n"
        analysis += "2. Review server configurations and security best practices\n"
        analysis += "3. Implement security headers and other hardening measures\n"
    
    return analysis

def generate_generic_analysis(tool: str, output: str, detail_level: str) -> str:
    """Generate a generic analysis for tools without specific parsers"""
    analysis = ""
    
    # Extract common patterns
    ip_addresses = re.findall(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', output)
    urls = re.findall(r'https?://[^\s<>"\']+', output)
    error_patterns = re.findall(r'(?:error|fail|warning|critical|exception|denied|refused|invalid)', output.lower())
    success_patterns = re.findall(r'(?:success|succeeded|completed|done|finished|ok)', output.lower())
    
    # Summary section
    analysis += "### Summary\n\n"
    
    # Generate a summary based on output size
    output_lines = output.count('\n')
    if output_lines > 20:
        analysis += f"The tool produced {output_lines} lines of output. "
        
        if error_patterns:
            analysis += f"Found {len(error_patterns)} potential error/warning indicators. "
        
        if success_patterns:
            analysis += f"Found {len(success_patterns)} success indicators. "
            
        if ip_addresses:
            analysis += f"Detected {len(set(ip_addresses))} unique IP addresses. "
            
        if urls:
            analysis += f"Found {len(set(urls))} URLs. "
            
        analysis += "\n\n"
    else:
        # For small outputs, just include a brief note
        analysis += f"Brief output ({output_lines} lines) from {tool}.\n\n"
    
    # Add found items
    if ip_addresses and detail_level == "detailed":
        analysis += "### IP Addresses Detected\n\n"
        for ip in set(ip_addresses):
            analysis += f"- {ip}\n"
        analysis += "\n"
        
    if urls and detail_level == "detailed":
        analysis += "### URLs Detected\n\n"
        for url in set(urls):
            analysis += f"- {url}\n"
        analysis += "\n"
    
    # Add error analysis if errors found
    if error_patterns:
        analysis += "### Potential Issues\n\n"
        
        # Extract lines with errors for context (up to 5)
        error_lines = []
        for line in output.split('\n'):
            if any(err in line.lower() for err in ['error', 'fail', 'warning', 'critical', 'exception']):
                error_lines.append(line.strip())
                if len(error_lines) >= 5:
                    break
        
        if error_lines:
            analysis += "The tool reported potential errors or warnings:\n\n"
            for line in error_lines:
                analysis += f"- {line}\n"
            
            if len(error_patterns) > 5 and detail_level == "concise":
                analysis += f"- ... and possibly more issues\n"
            analysis += "\n"
    
    # Add general advice
    analysis += "### Interpretation\n\n"
    analysis += f"This output is from the {tool} tool. "
    
    if error_patterns and not success_patterns:
        analysis += "The operation appears to have encountered errors without clear success indicators. "
    elif not error_patterns and success_patterns:
        analysis += "The operation appears to have completed successfully without obvious errors. "
    elif error_patterns and success_patterns:
        analysis += "The operation shows both success and error indicators, suggesting partial completion or non-critical warnings. "
    else:
        analysis += "The output doesn't contain obvious success or error indicators. "
    
    analysis += "For more specific analysis, consider using a tool-specific parser.\n\n"
    
    return analysis